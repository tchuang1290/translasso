% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oracleTransLasso.R
\name{oracleTransLasso}
\alias{oracleTransLasso}
\title{Oracle Transferred Lasso Estimator}
\usage{
oracleTransLasso(X0, y0, X1, y1, nfolds = 5, family = "gaussian", ...)
}
\arguments{
\item{X0}{A numeric matrix of predictors from the source domain.}

\item{y0}{A response vector corresponding to \code{X0}.}

\item{X1}{A numeric matrix of predictors from the target domain.}

\item{y1}{A response vector corresponding to \code{X1}.}

\item{nfolds}{Integer. Number of cross-validation folds. Default is 5.}

\item{family}{Character string specifying the model family.
Supported values are \code{"gaussian"}, \code{"binomial"}, \code{"poisson"}, or \code{"multinomial"}.
Default is \code{"gaussian"}.}

\item{...}{Additional arguments passed to \code{\link[=glmnet]{glmnet()}} or \code{\link[=cv.glmnet]{cv.glmnet()}}.}
}
\value{
\itemize{
\item If \code{family = "multinomial"}, a list of coefficient matrices, one for each class.
\item Otherwise, a matrix of estimated coefficients.
}
}
\description{
Fits a two-stage Lasso model where information is transferred from a source dataset to a target dataset. This method estimates an initial model using the combined datasets, computes an offset based on the source data,
and then fits a second Lasso model on the target dataset adjusted for this offset.
}
\details{
The function first fits a Lasso model on the combined dataset \verb{(X0, y0)} and \verb{(X1, y1)}
using cross-validation to select the best \verb{\\lambda}. Then, it computes predicted offsets based on the estimated coefficients from the source data \code{X0}.
Finally, it fits a second Lasso model to the source data adjusted by the offset, producing a final estimate of the coefficients.

Stratified folds are used for cross-validation when \code{family} is \code{"binomial"} or \code{"multinomial"}.
}
\examples{
\dontrun{
p <- 1000
n0 <- 100
n <- 500
reps <- 10
delta1_list <- numeric(reps)
delta2_list <- numeric(reps)

for (r in 1:reps){
  X0 = matrix(rnorm(n0*p), nrow = n0, ncol = p)
  X1 = matrix(rnorm(n*p), nrow = n, ncol = p)

  beta = runif(p, -2, 2) * sample(c(0,1), p, replace = TRUE, prob = c(0.9, 0.1))
  beta0 = beta + runif(p, -1, 1) * sample(c(0,1), p, replace = TRUE, prob = c(0.95, 0.05))

  y0 = X0\%*\%beta0 + rnorm(n0)
  y1 = X1\%*\%beta + rnorm(n)

  oracle_beta = oracleTransLasso(X0,y0,X1,y1)
  cvmodel = cv.glmnet(X0,y0, alpha = 1)
  best_lambda = cvmodel$lambda.min
  best_model = glmnet(X0,y0, alpha = 1, lambda = best_lambda)
  non_oracle_beta = as.matrix(coef(best_model))

  delta1_list[r] = sum((oracle_beta[-1] - beta0)^2)
  delta2_list[r] = sum((non_oracle_beta[-1] - beta0)^2) }

mean(delta1_list)
mean(delta2_list)
median(delta1_list)
median(delta2_list)
range(delta1_list)
range(delta2_list)
}
}
